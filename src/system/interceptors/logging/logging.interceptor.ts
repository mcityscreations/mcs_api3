// src/system/interceptors/logging.interceptor.ts

/**
 * @description This module is an interceptor that calculates the duration
 * of a request and logs the end of this request.
 * The correlationId is generated by the correlationId Middleware.
 * This same middleware stores the ID in the ALS.
 * The ALS acts as a bridge between the middleware and the interceptor.
 */

import {
	CallHandler,
	ExecutionContext,
	Injectable,
	NestInterceptor,
	HttpException,
} from '@nestjs/common';
import { Observable } from 'rxjs';
import { tap } from 'rxjs/operators';
import { Request, Response } from 'express';
import { WinstonLoggerService } from 'src/system/logger/logger-service/winston-logger.service';

@Injectable()
export class LoggingInterceptor implements NestInterceptor {
	constructor(private readonly loggerService: WinstonLoggerService) {}

	intercept(context: ExecutionContext, next: CallHandler): Observable<any> {
		const now = Date.now();
		const request: Request = context.switchToHttp().getRequest();

		return next.handle().pipe(
			tap({
				next: () => {
					const response: Response = context.switchToHttp().getResponse();
					this.logRequest(request, response.statusCode, now);
				},
				error: (err: unknown) => {
					const errorData = err
						? this.getErrorData(err)
						: this.getErrorData(new Error('Unknown error'));
					this.logRequest(request, errorData.statusCode, now, errorData);
				},
			}),
		);
	}

	private logRequest(
		request: Request,
		statusCode: number,
		startTime: number,
		errorData?: { message: string; statusCode: number; stack?: string },
	) {
		const latency = Date.now() - startTime;
		const message = `Requête ${errorData ? 'échouée' : 'terminée'}`;

		if (errorData) {
			this.loggerService.error(errorData.message, errorData.stack, {
				method: request.method,
				url: request.url,
				statusCode: errorData.statusCode,
				latency: `${latency}ms`,
			});
		} else {
			this.loggerService.log(message, {
				method: request.method,
				url: request.url,
				statusCode: statusCode,
				latency: `${latency}ms`,
			});
		}
	}
	/** Helper that retrieves error message, code and stack */
	getErrorData(error: unknown): {
		message: string;
		statusCode: number;
		stack?: string;
	} {
		let statusCode: number;
		let errorMessage: string;
		let stack: string | undefined;
		if (!error) {
			return {
				message: 'Unknown error',
				statusCode: 500,
				stack: undefined,
			};
		}
		if (error instanceof HttpException) {
			statusCode = error.getStatus();
			errorMessage = error.message;
			stack = error.stack;
		} else if (error instanceof Error) {
			statusCode = 500;
			errorMessage = error.message;
			stack = error.stack;
		} else {
			statusCode = 500;
			errorMessage = 'Unknown error';
			stack = undefined;
		}
		return {
			message: errorMessage,
			statusCode,
			stack,
		};
	}
}
